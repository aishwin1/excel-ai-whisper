
import * as XLSX from 'xlsx';

export interface ExcelData {
  sheets: {
    [sheetName: string]: {
      data: any[][];
      activeCell?: {
        row: number;
        col: number;
      };
    };
  };
  activeSheet: string;
}

export class ExcelService {
  static parseExcelFile(file: File): Promise<ExcelData> {
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      
      reader.onload = (e: ProgressEvent<FileReader>) => {
        try {
          if (!e.target?.result) {
            throw new Error("Failed to read file");
          }
          
          const data = new Uint8Array(e.target.result as ArrayBuffer);
          const workbook = XLSX.read(data, { type: 'array' });
          
          const excelData: ExcelData = {
            sheets: {},
            activeSheet: workbook.SheetNames[0]
          };
          
          workbook.SheetNames.forEach(sheetName => {
            const worksheet = workbook.Sheets[sheetName];
            const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 }) as any[][];
            
            excelData.sheets[sheetName] = {
              data: jsonData
            };
          });
          
          resolve(excelData);
        } catch (error) {
          console.error("Error parsing Excel file:", error);
          reject(error);
        }
      };
      
      reader.onerror = (error) => reject(error);
      reader.readAsArrayBuffer(file);
    });
  }

  static createEmptySheet(): ExcelData {
    // Create a basic empty sheet with headers
    return {
      sheets: {
        'Sheet 1': {
          data: [
            Array(15).fill(0).map((_, i) => String.fromCharCode(65 + i)),
            ...Array(20).fill(0).map(() => Array(15).fill(''))
          ]
        }
      },
      activeSheet: 'Sheet 1'
    };
  }

  static exportToExcel(data: ExcelData): Blob {
    const workbook = XLSX.utils.book_new();
    
    Object.entries(data.sheets).forEach(([sheetName, sheetData]) => {
      const worksheet = XLSX.utils.aoa_to_sheet(sheetData.data);
      XLSX.utils.book_append_sheet(workbook, worksheet, sheetName);
    });
    
    const excelBuffer = XLSX.write(workbook, { bookType: 'xlsx', type: 'array' });
    return new Blob([excelBuffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
  }

  static applyOperation(excelData: ExcelData, operation: any): ExcelData {
    // Create a deep copy of the data to avoid direct mutations
    const updatedData = JSON.parse(JSON.stringify(excelData));
    const activeSheet = updatedData.activeSheet;
    const sheetData = updatedData.sheets[activeSheet].data;
    
    try {
      switch (operation.type) {
        case "update_cell":
          if (operation.data && typeof operation.data.row === 'number' && typeof operation.data.col === 'number') {
            // Ensure the row exists
            while (sheetData.length <= operation.data.row) {
              sheetData.push(Array(15).fill(''));
            }
            
            // Ensure the column exists
            if (!sheetData[operation.data.row]) {
              sheetData[operation.data.row] = Array(15).fill('');
            }
            
            while (sheetData[operation.data.row].length <= operation.data.col) {
              sheetData[operation.data.row].push('');
            }
            
            // Mark this as AI generated by adding a prefix if it's a string value
            const value = operation.data.value;
            sheetData[operation.data.row][operation.data.col] = value;
          }
          break;
          
        case "add_formula":
          if (operation.data && operation.data.formula) {
            const { row = 1, col = 1, formula } = operation.data;
            
            // Ensure rows and columns exist
            while (sheetData.length <= row) {
              sheetData.push(Array(15).fill(''));
            }
            
            if (!sheetData[row]) {
              sheetData[row] = Array(15).fill('');
            }
            
            while (sheetData[row].length <= col) {
              sheetData[row].push('');
            }
            
            sheetData[row][col] = formula;
          }
          break;
          
        case "create_chart":
          // In a real implementation, this would create a chart object
          // For now, we'll just add a placeholder text
          if (!sheetData[1]) sheetData[1] = Array(15).fill('');
          sheetData[1][0] = `[AI Generated Chart: ${operation.data?.chartType || 'bar'}]`;
          sheetData[1][1] = `${operation.data?.title || 'Chart Title'}`;
          break;
          
        case "sort":
          if (operation.data && operation.data.column) {
            const colIndex = operation.data.column.charCodeAt(0) - 65; // Convert A->0, B->1, etc.
            if (colIndex >= 0 && sheetData.length > 1) {
              const headerRow = sheetData[0];
              const dataRows = sheetData.slice(1);
              
              dataRows.sort((a, b) => {
                const aVal = a[colIndex];
                const bVal = b[colIndex];
                
                if (typeof aVal === 'number' && typeof bVal === 'number') {
                  return aVal - bVal;
                }
                
                return String(aVal).localeCompare(String(bVal));
              });
              
              updatedData.sheets[activeSheet].data = [headerRow, ...dataRows];
            }
          }
          break;
          
        case "filter":
          // Simple filter implementation (placeholder)
          if (operation.data && operation.data.criteria) {
            // For now, just mark that a filter has been applied
            if (!sheetData[0][0]) sheetData[0][0] = "Column A";
            sheetData[0][0] = `${sheetData[0][0]} (Filtered)`;
          }
          break;
      }
    } catch (error) {
      console.error("Error applying Excel operation:", error);
    }
    
    return updatedData;
  }
}
